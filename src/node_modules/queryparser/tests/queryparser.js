var decomposedqueries = {
    'smith': { canonical: 'keyword:smith', syntax: 'qp' },
    'author:smith': { canonical: 'author:smith', syntax: 'qp' },
    'author:smith title:book': { canonical: '(author:smith && title:book)', syntax: 'qp' },
    'title: book author:smith': { canonical: '(title:book && author:smith)', syntax: 'qp' },
    'whatever title:book': { canonical: '(keyword:whatever && title:book)', syntax: 'qp' },
    'author[smith, james]': {
        canonical: 'author[smith, james]',
        facets: [ { type: 'author', label: 'Author', value: 'smith, james', link: 'author%5Bsmith%2C%20james%5D' } ],
        syntax: 'qp'
    },
    '{{author:smith}}' : { canonical: '{{author:smith}} ', syntax: 'qp' },
    '{{author:smith}} stuff': { canonical: '{{author:smith}} (keyword:stuff)', syntax: 'qp' },
    'stuff {{author:smith}}': { canonical: '{{author:smith}} (keyword:stuff)', syntax: 'qp' },
    'smith range<0 20>': { canonical: '(keyword:smith && range<0 20>)', syntax: 'qp' }
};

var expect = require('chai').expect,
    queryparser = require('../');

describe('Query parser', function () {
    before(function (done) {
        queryparser.initialize({
            operators: {
                'AND': '&&',
                'OR': '\\|\\|',
                'FLOAT_START': '\\{\\{',
                'FLOAT_END': '\\}\\}',
                'GS': '\\(',
                'GE': '\\)',
                'REQ': '\\+',
                'DIS': '-',
                'MOD': '#',
                'NOT': '!',
                'FACET_START': '\\[',
                'FACET_END': '\\]',
                'FILTER_START': '(range)<',
                'FILTER_END': '>'
            },
            indexes: {
                author: {
                    type: 'edge',
                    unidirected: false
                },
                title: {
                    type: 'text'
                },
                keyword: {
                    type: 'text',
                    unique: false,
                    multivalue: false
                },
                key: {
                    type: 'property',
                    datatype: 'String',
                    unique: true,
                    multivalue: false
                },
                recordtype: {
                    type: 'edge',
                    unidirected: true
                },
                model: {
                    type: 'property',
                    datatype: 'String',
                    unique: false,
                    multivalue: false
                },
                linkbrowse: {
                    type: 'dbcallback'
                },
                vorder: {
                    type: 'property',
                    datatype: 'Integer',
                    unique: false,
                    multivalue: false
                }
            },
            linktypes: {
                "author": {
                    "outlabel": "By",
                    "inlabel": "Wrote",
                    "facetlabel": "Author"
                },
            }
        });
        done();
    });
    Object.keys(decomposedqueries).forEach(function (query) {
        it('decomposes ' + query + ' properly', function () {
            var decomposed = queryparser.decompose(queryparser.parse(decomposedqueries[query].syntax, query));
            delete decomposedqueries[query].syntax;
            for (var key in decomposedqueries[query]) {
                expect(decomposed[key]).to.deep.equal(decomposedqueries[query][key]);
            }
        });
    });
});
