"use strict";
var extend = require('extend'),
    environment = require('../../../lib/environment'),
    graphstore = environment.graphstore,
    g = graphstore.g,
    Text = g.java.import('com.thinkaurelius.titan.core.attribute.Text'),
    LongEncoding = g.java.import('com.thinkaurelius.titan.util.encoding.LongEncoding');

var analysis = { };
var optimizer = { };

var dbcallbacks = {
    'linkbrowse': function (object) {
        analysis.linkbrowse = object[1];
        return g.v(object[1]).both().dedup();
    }
};

var operations = {
    'edge': function (pipeline, label, value) {
        return pipeline.out(label).has('key', value).back(2);
    },
    'inverseedge': function (pipeline, label, value) {
        return pipeline.in(label).has('key', value).back(2);
    },
    'biedge': function (pipeline, label, value) {
        return pipeline.both(label).has('key', value).back(2);
    }
};

module.exports = function (input, callback) {
    analysis = { };
    optimizer = {
        gremlinops: [ ]
    };
    var plan = environment.querybuilder.build(input.query.ast);
    var records;
    var list;
    var summary = 'All records';
    if (plan.unoptimizable) {
        if (graphstore.engine === 'titan') {
            optimizer.vertexquery = graphstore.db.querySync();
        }
        list = new g.ArrayList();

        var pipeline = searchTree(input.query.ast, g.V());
        if (typeof optimizer.vertexquery !== 'undefined') {
            pipeline = terminateVertexQuery(pipeline);
        }
        records = pipeline.aggregate(list).range(input.offset, input.offset + input.perpage - 1).toJSON();
        list = list.toJSON();
        if (analysis.linkbrowse) {
            summary = 'Links for ' + analysis.linkbrowse;
        } else if (input.query.canonical) {
            summary = 'Search: ' + input.query.canonical;
        }
        callback(extend({
            records: records,
            more: true,
            list: list,
            summary: summary
        }, analysis));
    } else {
        handleOptimizedQuery(input, plan, callback);
    }
};

module.exports.message = 'search';

function handleOptimizedQuery(input, plan, callback) {
    if (plan.esquery) {
        if (typeof plan.esquery.fields === 'undefined') {
            plan.esquery.fields = environment.esclient.fields;
        }
        environment.esclient.search('bn_moa', 'vertex', plan.esquery, function (err, data) {
            var list = [ ];
            if (typeof err === 'undefined') {
                data = JSON.parse(data);
                var records = [ ];
                data.hits.hits.forEach(function (hit, index) {
                    var rec = { };
                    rec._id = LongEncoding.decodeSync(hit._id);
                    list.push(rec._id);
                    if (plan.esonly && index >= input.offset && index < input.offset + input.perpage) {
                        for (var key in hit.fields) {
                            rec[environment.esclient.index[key]] = hit.fields[key];
                        }
                        records.push(rec);
                    }
                });
            }
            if (plan.vertexquery.length > 0 || plan.pipeline.length > 0){
                handleVQandPipeline(input, plan, list, callback);
            } else {
                callback({
                    records: records,
                    more: true,
                    list: list,
                    summary: 'Search: ' + input.query.canonical
                });
            }
        });
    } else {
        handleVQandPipeline(input, plan, null, callback);
    }
}

function handleVQandPipeline(input, plan, list, callback) {
    var pipe;
    var op;
    if (list === null) {
        if (plan.vertexquery.length > 0) {
            pipe = graphstore.db.querySync();
            while (op = plan.vertexquery.shift()) {
                pipe = pipe.hasSync.apply(pipe, op);
            }
            pipe = g.start(pipe.verticesSync());
        }
    } else {
        pipe = g.v(list);
        while (op = plan.vertexquery.shift()) {
            pipe = pipe.has.apply(pipe, op);
        }
    }
    while (op = plan.pipeline.shift()) {
        pipe = pipe[Object.keys(op)[0]].apply(pipe, op[Object.keys(op)[0]]);
    }
    list = new g.ArrayList();
    var records = pipe.aggregate(list).range(input.offset, input.offset + input.perpage - 1).toJSON();
    list = list.toJSON();
    callback({
        records: records,
        more: true,
        list: list,
        summary: 'Search: ' + input.query.canonical
    });
}

function searchTree(tree, pipeline) {
    if (typeof tree === 'undefined') {
        return pipeline;
    }
    /*jshint -W086*/ /* No 'break' between cases */
    switch (tree[0]) {
    case 'AND':
        if (typeof optimizer.vertexquery !== 'undefined') {
            return searchTree(tree[1], searchTree(tree[2], pipeline));
        } else {
            return pipeline.and(searchTree(tree[1], g._()), searchTree(tree[2], g._()));
        }
    case 'OR':
        pipeline = terminateVertexQuery(pipeline);
        return pipeline.or(searchTree(tree[1], g._()), searchTree(tree[2], g._()));
    case 'NOT':
        pipeline = terminateVertexQuery(pipeline);
        return pipeline.except(searchTree(tree[1], pipeline));
    case 'HAS':
    case 'FACET':
        var value = searchTree(tree[2], null);
        switch (environment.indexes[tree[1]].type) {
        case 'property':
            if (typeof optimizer.vertexquery !== 'undefined') {
                optimizer.vertexquery = optimizer.vertexquery.hasSync(tree[1], value);
                return pipeline;
            } else {
                return pipeline.has(tree[1], value).back(1);
            }
        case 'text':
            if (typeof optimizer.vertexquery !== 'undefined') {
                value.split(' ').forEach(function (value) {
                    optimizer.vertexquery = optimizer.vertexquery.hasSync(tree[1], Text.CONTAINS, value);
                });
                return pipeline;
            } else if (graphstore.getEngine() === 'titan') {
                var verts = new g.ArrayList();
                g.start(graphstore.db.querySync().hasSync(tree[1], Text.CONTAINS, value).verticesSync()).aggregate(verts).iterate();
                return pipeline.retain(verts);
            } else {
                return pipeline.filter("{it.data?.count('" + value + "') >= 1}");
            }
        case 'dbcallback':
            pipeline = terminateVertexQuery(pipeline);
            return dbcallbacks[tree[1]](tree[2], pipeline);
        default:
            if (typeof optimizer.vertexquery !== 'undefined') {
                optimizer.gremlinops.push([ environment.indexes[tree[1]].type, tree[1], value ]);
            } else {
                return operations[environment.indexes[tree[1]].type](pipeline, tree[1], value);
            }
        }
    case 'PHRASE':
        return tree[1];
    case 'ATOM':
        return tree.slice(1).join(' ');
    case 'FLOAT':
        pipeline = searchTree(tree[1], pipeline);
        return searchTree(tree[2], pipeline);
    }
    /*jshint +W086*/
    return pipeline;
}

function terminateVertexQuery(pipeline) {
    if (typeof optimizer.vertexquery !== 'undefined') {
        pipeline = g.start(optimizer.vertexquery.verticesSync().iteratorSync());
        var op;
        /*jshint -W084*/ /* Assignment in loop */
        while (op = optimizer.gremlinops.pop()) {
            pipeline = operations[op[0]](pipeline, op[1], op[2]);
        }
        /*jshint +W084*/
        delete optimizer.vertexquery;
    }
    return pipeline;
}
